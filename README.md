# gridWorld

In this particular phase of the work we are asked to solve the Grid World problem using the python programming language. At the beginning of our code we write the python libraries we will use that will help us solve our problem. Then, we create the class named Environment where essentially in this class we will model the Grid World and the policy of our problem. Inside the class, the initialization and assignment of values, characters and variables, such as discount = 1 , the actions that we declare with characters the movements we can make in the table, the creation of the dimensions of the table. Next, we will create the function is_terminal_state, which will return when we are at position 0, that is, at the points of the array that we have defined as terminals based on the example, or when the point is outside the size of the array. In addition, we have the function named tick which understands which state of the table we are in and depending on the move we need to make returns the state we are in at that moment. In the following lines of our code we find the function named reward which when we are in a terminal state will reward us with 0, while when we are in any other state of the table it will reward us with -1. In the continuation of our code, we find the class named RandomPolicy whose property is to initially start from a state and then generate random moves. Then we start testing our code by going and putting in random states and setting up different moves that we could do. As we proceed, we come across the function evaluate_policy which has the property of evaluating the method we have implemented and prints all the values of the resulting states along with the rewards they receive. Next, we will see another method of solving the problem implemented, the GreedyPolicy which is a greedy method that the agent keeps running because it believes it will yield the highest reward, however this method will not allow our agent to explore at all. In this case, this class will pick the states with the highest payoff to reach termination and print all the moves it has made and their payoffs. In the following lines of our code we will attempt to stop at 3 iterations to observe the results of the optimized method we will have. Finally, we reach the last function of our code which is called iteration, where the process of repetition is actually carried out. In this case, we have two tables, one is the table in which we store the updated maximum rewards and states that we will be in the table, as the appropriate prints will also be made.
